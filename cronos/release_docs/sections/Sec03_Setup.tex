\section{Setting up a simulation}

\subsection{Files to be modified by the User}
\label{sect:userfiles}

All the files which have to be edited in order to set up and run a
simulation are located in the {\tt cronos/User} directory. 
Alternatively, it is possible to set up a separate directory (of arbitrary
name) for each group of projects in analogy to {\tt cronos/User}.
%In that case, the {\tt Makefile} should be adjusted to include all new
%mod files (see below) via the line \\
%{\tt MODULES\_FILES = mod\_}{\em mySim1}{\tt .H mod\_}{\em mySim2}{\tt .H} \\
%etc.
For the remainder of this document, all files will be assumed to reside in
this directory unless explicitly specified otherwise.

\begin{description}

\item[{\tt constants.H}]{\ }\\
includes very basic parameters and the definitions of some global
variables (see Section~\ref{sect:constants.H}).

\item[{\tt machinefile.local}]{\ }\\
For runs using multiple machines, this file contains a list of the hosts
and the number of CPUs to be used on that host (see
Section~\ref{sect:run_par}). For single-machine runs (and multicore runs on
clusters consisting of several cores on a single machine), this file is
irrelevant.

\item[{\tt modules.C}]{\ }\\
relates simulation classes to their types (see Section
\ref{sect:modules}).

\item[{\tt mod\_}{\it mySim}{\tt .H}]{\ }\\
  Routines specifically needed for the simulation project {\it mySim},
  realized as a C++ class of the same name. Initial and boundary
  conditions, source terms, etc. go here. Each project name that
  occurs in {\tt modules.C} requires a corresponding
  \verb+mod_*.H+ file to be present.

\item[{\tt Makefile}]{\ }\\
  to include external user directories, source files and additional compiler flags (see Section
\ref{sect:makefile}).
  

\end{description}

\subsection{The Simulation hierarchy}
\label{sect:modules}

Different simulation categories (representing, for instance, different
physical ``target objects''), are distinguished by their {\em type},
which is a unique (and usually small) integer. The relation between a
simulation category and that category's type is specified in the file
{\tt modules.C}. Therefore, the first step in the setup of a new
simulation project is to modify this file by adding
\begin{verbatim}
#include "mod_mySim.H"
\end{verbatim}
at the very beginning and inserting the code segment
\begin{verbatim}
  else if (type == simtype) {
    Problem = new mySim(gdata);
\end{verbatim}
where {\tt mySim} is the unique name of the project, and {\tt simtype}
is the project's unique type number. Lines referring to a category
which is not to be used can be removed along with the corresponding
mod file. The code segment for the minimum case of just one single
category would thus be
\begin{verbatim}
  if (type == simtype) {
    Problem = new mySim(gdata);
  } else {
    ...
\end{verbatim}
Each simulation of a given type (characterized by, e.g.\ different
sets of parameters) requires a so-called {\it cat file} (see
Section \ref{sect:catfile}), in which these parameters are specified.

\subsection{Entries of {\tt constants.H}}
\label{sect:constants.H}

Next, the file {\tt constants.H} should be inspected to see if changes
need to be made.

\subsubsection{Keywords}

% #define EXTRACT_PRESSURE FALSE 
% #define CRONOS_MOVIE CRONOS_ON
% #define USE_ANGULAR_MOMENTUM FALSE 

% const int N_ADD = 2;      // Used for div(B)


\begin{description}
  
\item[{\tt FLUID\_TYPE}]{\ }\\ Switch between hydro or MHD, single- or multifluid
  simulations. Must be either \verb+CRONOS_MULTIFLUID+, \verb+CRONOS_HYDRO+ or
  \verb+CRONOS_MHD+. With the latter option hydro runs are also
  possible, but in that case the former is more efficient (no memory
  allocated for magnetic field and several routines are skipped).

\item[{\tt  RK\_STEPS}]{\ }\\
  Order of accuracy to use for the Runge-Kutta time-stepping. Must be
  either {\tt 2} or {\tt 3}. 3rd order is generally more accurate,
  has the same memory requirements, but takes $\sim$50\% longer to
  run.
  
\item[{\tt GEOM}]{\ }\\
  Coordinate system to use. Currently supported choices are:\\
  \begin{tabular}{ccll}
    {\tt 1} &$\rightarrow$& Cartesian   &$[x, y,         z]$ \\
    {\tt 2} &$\rightarrow$& cylindrical &$[R, \varphi,   Z]$ \\
    {\tt 3} &$\rightarrow$& spherical   &$[r, \vartheta, \varphi]$
  \end{tabular}
  
\item[{\tt CT\_TYPE}]{\ }\\
  Variant of constrained transport to use. Recommended choices are: 
  {\tt CONSISTENT} when using the HLL Riemann solver, or
  {\tt STONE} for HLLD.
  
\item[{\tt STONE\_TYPE}]{\ }\\
  Possible choices are {\tt STONE\_SIMPLE} or {\tt STONE\_CENTRE}
  (recommended). Only matters if {\tt CT\_TYPE} is set to
  {\tt STONE}.
  
\item[{\tt DIM}]{\ }\\
  Number of dimensions. Currently, the only admissible value is
  {\tt 3}.
  
\item[{\tt ENERGETICS}]{\ }\\
  Set this to {\tt FULL} if Equation~(\ref{eq:NRG}) is to be integrated,
  or to {\tt ISOTHERMAL}\footnote{Note that this term is somewhat
    misleading, since the fluid need not be isothermal, depending on
    what adiabatic exponent is used.} if an adiabatic closure relation
  (see Section~\ref{sect:NRG}) is to be used. (This keyword has replaced
  the {\tt N\_OMEGA} variable known from previous versions.)
  
\item[{\tt CRSWITCH\_DUAL\_ENERGY}]{\ }\\
  Set this to {\tt CRONOS\_ON} to enable entropy correction (see
  Section\ref{sect:entropy}), else use {\tt CRONOS\_OFF}.
  
\item[{\tt NON\_LINEAR\_GRID}]{\ }\\
  Enable non-linear grid scaling ({\tt CRONOS\_ON}) or not
  ({\tt CRONOS\_OFF}). This is discussed in Section~\ref{sect:nonlin-grid}.
  
\item[{\tt REAL}]{\ }\\ Variable type to be used for floating point
  data. Admissible types are {\tt double} and {\tt float}, the former
  being the recommended choice. The latter may, however, be useful to
  decrease the code's memory consumption if necessary.
  
\item[{\tt OMS\_USER}]{\ }\\
  Use additional variable fields ({\tt TRUE}) or not ({\tt
    FALSE}). Has to be {\tt TRUE} if at least one of the projects
  listed in {\tt modules.C} uses additional variables.
  
\item[{\tt USE\_COROTATION}]{\ }\\  
  Perform simulations in a corotating frame of reference ({\tt CRONOS\_ON})
  or not ({\tt CRONOS\_OFF}). Requires entry {\tt omegaZ} in the cat file.
  See Section~\ref{sect:corotation} for details.
  
\end{description}

\subsubsection{Flags}

\begin{description}

\item[{\tt PHYSDISS}]{\ }\\
  Can be used to enable physical dissipation/ viscosity (currently
  undocumented code feature).
  
\item[{\tt MHD}, {\tt VEC\_POT\_BCS}]{\ }\\
  Reserved for future use, irrelevant as of now.
  
\item[{\tt SOUND}]{\ }\\
  This entry is obsolete, but should be left untouched until it will
  be cleanly removed from the code in a forthcoming revision.
  
% #define EXTRACT_PRESSURE TRUE
%Ralf:
%Das stammt aus der Zeit als ich den hlld eingebaut habe. Dabei habe
%ich die Resultate direkt mit einem andere Code vergleichen wollen, der
%standardmäßig den Druck separat behandelt und vor der Berechnung der
%hyperbolischen Flüsse abspaltet. Da ich mir nicht im Klaren bin, was
%da der effektive Unterschied ist, erlaube ich beides. Scheint aber
%nicht wirklich viel Unterschied zu machen. 

\item[{\tt SAVEMEM}]{\ }\\ For cases in which memory usage is an
  issue, this can be set to favor re-computation of some auxiliary
  variable fields over storing them for later use. Users interested
  in memory/ runtime opimisation are encouraged to experiment with
  this flag to quantify its performance impact for the given
  architecture. This flag only has an effect for
  \verb+FLUID_TYPE = CRONOS_MHD+.
  
\end{description}

\subsubsection{Variables}

\begin{description}
  
\item[{\tt const int B}]{\ }\\
  Number of ghost cell layers to be considered in the computation.
  
\item[{\tt const int BOUT\_FLT}]{\ }\\
  Number of ghost cell layers to include in FLOAT output (see
  Section~\ref{sec:out_float}). Must be \mbox{$\le$ {\tt B}}.
  
\item[{\tt const int BOUT\_DBL}]{\ }\\
  Number of ghost cell layers to include in DOUBLE output (see
  Section~\ref{sec:out_double}). Must be \mbox{$\le$ {\tt B}}.
  
\item[{\tt const int N\_OMINT\_USER}]{\ }\\
  Number of additional variable fields if such are taken into account
  (i.e.\ if \mbox{\tt OMS\_USER = TRUE} has been set). See
  Section~\ref{sec:extend} for details. 
  
\item[{\tt const int N\_P}]{\ }\\
  Obsolete, and to be removed in a forthcoming revision. Until then,
  best left untouched.
  
\item[{\tt const int N\_ADD}]{\ }\\
  Probably also obsolete, no need to touch it.
  
\end{description}
All else should be left untouched if possible. If you must use additional
global variables and/or keywords, these should be defined in this file
(that is, in {\tt constants.H}).

\subsection{The energy integration}
\label{sect:NRG}

Depending on how the energy budget is to be computed, different
settings are required:
\begin{itemize}
\item Isothermal ($p = \rho \ c_{\rm iso}^2$): Set {\tt ENERGETICS} to
  {\tt ISOTHERMAL} in {\tt constants.H} and edit the cat file (see
  Section~\ref{sect:catfile}) to set the adiabatic index $\gamma$ equal
  to unity and the isothermal sound speed $c_{\rm iso}$ equal to
  \mbox{$\sqrt{T_0}$}, where $T_0$ is the desired constant temperature.
\item Adiabatic ($p \propto \rho^{\gamma}$): Same as above, but with
  \mbox{$\gamma \ne 1$}. Note that in this case the constant of
  proportionality is fixed via
  \begin{equation}
    \frac{p}{p_0} = \left(\frac{\rho}{\rho_0}\right)^{\gamma}
    \ \Rightarrow \
    p = \frac{c_{\rm iso}^2}{(\rho_0)^{\gamma-1}} \ \rho^{\gamma}
  \end{equation}
  where the initial density $\rho_0$ is again specified in the cat file.
  This is only permissible if initially $\rho=\rho_0$ holds throughout the
  entire volume! For initial setups involving a spatially varying density,
  a full energy equation (see next item) is mandatory, even if no energy
  source terms are being used.
\item To solve a full energy equation (\ref{eq:NRG}), set {\tt ENERGETICS}
  to {\tt FULL} and $\gamma \ne 1$. In this case, the $c_{\rm iso}$ and
  $\rho_0$ cat entries are not used (but may still be accessed via the
  {\tt rho0} and {\tt c2\_iso} member variable/function).
\end{itemize}

\subsection{Corotating frame of reference}
\label{sect:corotation}

It is often desirable to perform the simulations in a corotating frame of
reference to simplify boundary conditions. Implementing the resulting
fictitious (Coriolis-, centrifugal-, and Euler) forces as source terms
can lead to instabilities and non-conservation of angular momentum. Instead,
a conservative treatment was developed, which results in the following set of
equations. These are equivalent to the original ideal MHD equations with
fictitious forces as source terms, such that the new set
\begin{eqnarray}
  \partial_t \rho + \nabla \cdot \left( \rho {\bf v} \right) &=& 0 \\
  \partial_t \left( \rho {\bf u} \right)
  + \nabla \cdot \left[ \rho {\bf v u} 
    + (p + \|{\bf B}\|^2/2 ) {\cal I}-{\bf B B} \right]
  &=& -\rho{\bf \Omega}\times{\bf u} \\
  \partial_t e + \nabla \cdot \left[e {\bf v} + (p+\|{\bf B}\|^2/2){\bf u}
    - ({\bf u} \cdot {\bf B}) {\bf B} \right] &=& 0
\end{eqnarray}
replaces Eqs.~(\ref{eq:cont}--\ref{eq:NRG}), and Ohm's law (\ref{eq:ohm})
is now
\begin{equation}
  {\bf E} + {\bf v} \times {\bf B} = {\bf 0} \ .
\end{equation}
Here, ${\bf v}$ denotes the velocity in the corotating frame, which is
related to the inertial frame velocity ${\bf u}$ via
\begin{equation}
  {\bf v} = {\bf u} + {\bf r} \times {\bf \Omega} \ . 
\end{equation}
The implementation is such that the axis of rotation conincides with the
$z$ axis. To enable this feature, set {\tt USE\_COROTATION CRONOS\_ON} in
{\tt constants.H}. The value for the rotation frequency $\Omega$ has to be
set in the cat file using the {\tt omegaZ} variable. In the mod file, the
user deals with the corotating frame velocity ${\bf v}$ and has to set
initial- and boundary conditions as well as additional source- and flux
terms accordingly. The function {\tt init\_fields} has to be supplemented
at the top by
\begin{verbatim}
#if (USE_COROTATION == CRONOS_ON)
  gdata.om[q_sx].rename("v_x_Corot");
  gdata.om[q_sy].rename("v_y_Corot");
  gdata.om[q_sz].rename("v_z_Corot");
#endif
\end{verbatim}

\subsection{Entropy correction}
\label{sect:entropy}

If the ratio of thermal to total energy changes sharply (e.g. at shock
fronts), numerical inaccuracies may lead to negative values of pressure
and/or temperature, at which times the code has to abort because the sound
speed becomes undefined. The suggestion of \cite{L:Balsara_Spicer} is to
integrate an additional equation
\begin{equation}
  \partial_t s + \nabla \cdot \left( s \ {\bf u} \right) = 0
\end{equation}
for the entropy density $s \equiv p / \rho^{\gamma-1}$ and to compute $p$
from $s$ rather than $e$ whenever the former value appears to be more
trustworthy for a given cell (and in particular when $e_{\rm therm}$ has
become negative).\\
For runs which are prone to negative pressures, this entropy correction
should be enabled (albeit at the cost of slightly increased numerical
expenditure, and less accurate results). Otherwise do not use it.


\subsection{Choice of Riemann solvers}
\label{sect:riemann}
Three types of Riemann solvers are available, and can be specified in the
cat file:
\begin{enumerate}
\item HLL: most simple Riemann solver. Very stable but also more
  dissipative than the other options.
 % At the same time this solver has      WFT??
 % an \emph{consistent} for the computation of the electric fields in
 % MHD simulations.
\item HLLC: recommended solver for HD. For isothermal runs this is
  equivalent to HLL
\item HLLD: recommended for MHD. Set {\tt EXTRACT\_PRESSURE} to {\tt FALSE}
  in {\tt constants.H} when using this solver. (For the others this does not
  matter.)
\end{enumerate}
Unsuitable choices will be rejected, and a comment is issued.

\subsection{Setting up the mod file}

Next, the inital conditions, as well as possible source terms and
special boundary conditions (if so desired), need to be specified, all
of which occurs in the file {\tt mod\_}{\it mySim}{\tt.H} (whose name
should correspond to the one chosen in {\tt modules.C}). Any
additional, non-standard procedures can also be implemented here. (For
the following, it is advisable to copy an existing mod file and make
the needed changes there, rather than writing one from scratch.)
In this file, the simulation (again dubbed {\tt mySim} in this
example) is set up as a C++ class, the basic skeleton of which looks
like this:\\
\begin{center}
\begin{verbatim}
#ifndef CRONOS_MYSIM_H
#define CRONOS_MYSIM_H = 1

#include "gridgen.H"

class mySim:public ProblemType {
public:
  mySim(Data &);
  void init_fields(Data &, int [], int []);
private:
  REAL my_param;
};

mySim::mySim(Data &gdata) {
  name = " My new simulation ";
  this->my_param = value((char*)"My Parameter");
}

void mySim::init_fields(Data &gdata, int ibeg[3], int iend[3])
{
  for (int k = ibeg[2]; k <= iend[2]; ++k)
    for (int j = ibeg[1]; j <= iend[1]; ++j)
      for (int i = ibeg[0]; i <= iend[0]; ++i)
        gdata.om[0](i,j,k) = density_function(i,j,k);
        gdata.om[2](i,j,k) =     v_y_function(i,j,k);
}

#endif
\end{verbatim}
\end{center}
Three blocks of code can be identified:
\begin{enumerate}
\item The {\em class definition} (starting with the {\tt class} keyword) lists
  all functions and variables of the problem class.
\item The {\em constructor} has the same name as the class and lacks a return
  type. It gets called only once at the beginning. Class-wide variables
  should be defined here. For clarity of output, a name should (but need not)
  be set by (re-)defining the {\tt name} string variable.
\item The initialization routine called {\tt init\_fields}, see
  Section~\ref{sec:init_fields}.
\end{enumerate}
(Note the leading \verb+#ifndef+/\verb+#define+ directives, which
exist to prevent the compiler from including the same section multiple
times. The keyword can in principle be chosen freely but must be
unique, which is easily achieved by using some variant of the project
name.)


\subsubsection{Read parameters}

The class constructor is a good location to read parameters from the cat file
via the {\tt value} method. This method's syntax is\\
{\tt REAL param = value((char*)"{\it parameter\_name}");}\\
It scans the text file {\it datadir}{\tt /}{\it pname}{\tt .cat} for
the line\\
\centerline{\it parameter\_name {\tt =} value}
and returns the floating point value of {\it value}. If the search
comes up empty, an error message is issued. If more than one
whitespace-separated entry follow the equal sign, only the first
entry is returned, and the rest ignored\footnote{This suggests that if
you tentatively modify a parameter, you can leave the original value
standing in the same line, and later easily revert to it without
having to remember it in the meantime.}.
Having been declared in the {\tt private} section, its value can now
be accessed from all methods of the class (but not from outside). For
more info on cat files see Section~\ref{sect:catfile}.

\subsubsection{Initial conditions}
\label{sec:init_fields}

Any {\tt ProblemType} class {\em must} provide the method
{\tt ::init\_fields}, which defines the initial conditions. The
{\tt gdata} object contains the properties of both the grid and the
values of the physical fields on the grid. These data can be accessed
according to Table~\ref{tab:struct_gdata}.
{\tt ibeg[]} and {\tt ibeg[]} hold the first and last indices of the
part of the grid which the current process works on (including the
ghost cell layers). For the single-CPU case, they are thus equal to
$[-B,-B,-B]$ and $[N_x-1+B, N_y-1+B, N_z-1+B]$, where $B$ is the {\tt B}
value from {\tt constants.H}. Fields which lack an explicit
initialization are initialized to zero.\\
{\tt om[$q$]($i$,$j$,$k$)} denotes the value of of the physical field $q$
at the rid cell $(x_i,y_j,z_k)$, where $q$ is chosen from
Table~\ref{tab:qvals}.
\begin{table}
  \begin{center}
    \begin{tabular}{ll|ll}
      $ \begin{array}{l} {\tt q\_rho}  \end{array}$ &   mass density &
      $ \begin{array}{l} {\tt q\_Eges} \end{array}$ & energy density \\
      $ \left. \begin{array}{l} 
          {\tt q\_sx} \\ {\tt q\_sy} \\ {\tt q\_sz}
        \end{array} \right\}$ &
      $ \left\{ \begin{array}{l}
        \mbox{velocity} \\ \mbox{components}
      \end{array} \right. $ &
      $ \left. \begin{array}{l} 
          {\tt q\_Bx} \\ {\tt q\_By} \\ {\tt q\_Bz}
        \end{array} \right\}$ &
   $ \left\{ \begin{array}{l} 
     \mbox{magnetic field/} \\  \mbox{vector potential} \\
     \mbox{components}
      \end{array} \right. $
    \end{tabular}
    \caption{\label{tab:qvals}
      Admissible $q$ values to refer to (standard) physical fields.
    }
  \end{center}
\end{table}
It should be noted that {\tt gdata.om[q\_Eges]} denotes just the thermal
part $e_{\rm th} \equiv p/(\gamma-1)$ of the total energy density. The same
is true for the boundary conditions and source terms (although this
distinction is not of great importance for these two cases).
By default, {\tt gdata.om[q\_B\{x,y,z\}]} denote the components of the initial
magnetic field. It can, however, be more appropriate to use the vector
potential instead, the advantage being that the code will
compute the corresponding ${\bf B}$ from $\nabla \times {\bf A}$, such
that $\nabla \cdot {\bf B}=0$ is automatically satisfied. Otherwise,
the user himself has to make absolutely sure that this is the
case\footnote{It is vital that this constraint be satisfied numerically
for the discretized field, not just analytically for the formulas used
in the assignment.}.
To use {\bf A} rather than {\bf B}, insert the lines
\begin{verbatim}
  gdata.om[q_Bx].rename("A_x");
  gdata.om[q_By].rename("A_y");
  gdata.om[q_Bz].rename("A_z");
\end{verbatim}
before assigning the components of {\bf A} to {\tt gdata.om[q\_B\{x,y,z\}]},
and make sure that the shift of indices (cf. Table~\ref{tab:ab_comp})
is taken into account.

\begin{table}[bh!]
  \begin{tabular}{ll}
    {\tt gdata.}name & meaning \\
    \hline
        {\tt REAL om[$q$]($i$,$j$,$k$)} &
        value of variable $q \in \{ {\tt q\_rho}, \ldots \} $
        at $(i,j,k)$ \\      
        {\tt REAL xb[$d$]} & $d \in [0, 1, 2] \rightarrow
        [x_0,y_0,z_0]$ \\
        {\tt REAL dx[$d$]} & $d \in [0, 1, 2] \rightarrow
        [\Delta x, \Delta y, \Delta z]$ \\
        {\tt int mx[$d$]} & $d \in [0, 1, 2] \rightarrow
        [N_x-1, N_y-1, N_z-1]$ \\
        {\tt REAL h$c$($i$,$j$,$k$)} & $c \in [1,2,3]$
        $\rightarrow$ scale factor $h_c$ for direction $c$\\
        {\tt REAL time} & current simulation time \\
        {\tt REAL dt} & current timestep \\
        {\tt REAL t\_end} & time after which simulation run will halt \\
        {\tt getCen\_x($i$)} & returns cell center $x_i$ as a
        function of index $i$,\\ & and analogously for
        {\tt getCen\_y} and {\tt getCen\_z}. \\
        {\tt get\_x($i$,$s$)} & corresponds to
        {\tt getCen\_x($i+s/2$)}, $s \in \{0,\pm 1\}$ \\
        & and similarly for {\tt get\_y($j$,$s$)} and {\tt get\_z($k$,$s$)} \\
        {\tt get\_pos($d$,$i$,$s$)} &  $d \in [0, 1, 2] \rightarrow
        [${\tt get\_x($i$,$s$)}, $\ldots$, {\tt get\_z($i$,$s$)}$ ]$   \\
        {\tt get\_x\_global($i$,$s$)}
        & grid-wide version of {\tt get\_x($i$,$s$)} \\
        {\tt get\_pos\_global($d$,$i$,$s$)}
        & grid-wide version of {\tt get\_pos($d$,$i$,$s$)} \\
        {\tt get\_CellVolume($i$,$j$,$k$)} & geometric volume of cell \\
       \hline
  \end{tabular}
  \caption{\label{tab:struct_gdata}
    Some important members of {\tt gdata}. All of $\{i, j, k, d, s \}$
    are integers. All {\tt get\_*} functions return {\tt REAL}.
    For routines without ``{\tt global}'' in their names, positional indices
    $(i,j,k)$ refer to the subgrid that the given processor works on, i.e.,
    $i$ runs from 0 to $N_x/${\tt nprocx} and similarly for $j$ and $k$.
    For a more complete (but largely uncommented) list consult the
    respective implementations in {\tt grid.C}.
  }
\end{table}

\subsubsection{Boundary conditions}

Arbitrary boundary conditions other than periodic, extrapolation,
outflow, or reflecting (which should be set directly in the cat file,
see Section~\ref{sect:catfile}) can be achieved on any of the six sides
of the computational volume by implementing the method
\begin{verbatim}
void mySim::bc_User(Data &gdata, NumMatrix<REAL,3> &omb,
                    int dir, int top, int q, int rim) 
\end{verbatim}
which can be used to set any boundary condition for the physical field
{\tt omb} (= {\tt gdata.om[$q$]}) of number $q$ (cf. Table~\ref{tab:qvals}
in coordinate direction {\tt dir} ({\tt 0,1,2} for $x$,$y$,$z$) and side
(cube face) {\tt top} ({\tt 0} = min, {\tt 1} = max). As before,
\verb+gdata.om[q_Eges]+ denotes thermal (not total) energy density. If nothing
is specified for a given $q$ and boundary, an error message will be issued. \\
To make a quantity simply retain its initial values at that boundary (Dirichlet
boundary condition), this value has to be specified explicitly.\footnote{In the
future, it will be possible to implement a Dirichlet BC using another type in
the cat file; this is scheduled to be realized in a forthcoming edition.}


\subsubsection{Source terms}
Physical source terms such as gravity and heating functions, which are
to be included on the right hand sides of the equations
(\ref{eq:cont}) to (\ref{eq:NRG}), can be specified by implementing
\begin{verbatim}
void mySim::src_User(Data &gdata,
                     NumMatrix<REAL,3> nom     [N_OMINT     ],
                     NumMatrix<REAL,3> nom_user[N_OMINT_USER])
\end{verbatim}
Source terms for the standard equations for variable $q$ at cell
$[i,j,k]$ are assigned using \\
\verb+   nom[q](i,j,k) -= some_function(i,j,k);+ \\
(Note the minus sign, and be sure {\it not} to use {\tt =} instead of
{\tt -=}.) In the case of additional variables, use\\
\verb+   nom_user[q](i,j,k) -= some_other_function(i,j,k);+ \\
instead.

\subsubsection{Coordinate singularities}

In many cases, the desired computational domain may contain one or more
coordinate singularities, which are defined as regions where at least one
scale factor tends to zero (implying that several vertices of a cell coincide,
leading to wedge-shaped cell geometries). For cylindrical coordinates, this
can only occur at the axis $R=0$, while for spherical coordinates, the three
possible cases are $\vartheta=0$ (``north pole''), $\vartheta=\pi$
(``south pole''), and the origin at $r=0$. If these locations are to be
included, the grid should be specified such that the singularity exactly
coincides with a cell face. Furthermore, it is necessary to include the
keyword {\tt Include\_CoordinateAxis} (previously {\tt IncludeAxis}) into the
cat file to activate the singularity treatment. The effect of this is two-fold:
\begin{enumerate}
\item Since boundary cells at $R_{\rm min}$ (cylindrical) or
$\vartheta_{\rm min/max}$ and $r_{\rm min}$ (spherical) are physically
equivalent to internal cells on the other side of the singularity, the cell
contents is copied from there, possibly amended with a minus sign that follows
from symmetry considerations (see Table~\ref{tab:singular}).
\begin{table}
  \begin{tabular}{llll}
    coord. system & boundary & cells to copy & minus sign for \\ \hline
    cylindrical   & $R=0$ & $[R,\varphi,z]
    \leftarrow [-R,\varphi \pm \pi,z]$ & $R,\varphi$ components \\
    spherical & $\vartheta \in \{0,\pi\}$ & $[r,\vartheta,\varphi]
    \leftarrow [r,\vartheta,\pi \pm \varphi]$ & $r,\varphi$ components \\
    spherical & $r=0$ & $[r,\vartheta,\varphi]
    \leftarrow [r,\pi-\vartheta,\pi \pm \varphi]$ &
    $r,\vartheta, \varphi$ components \\
    \hline
  \end{tabular}
  \caption{\label{tab:singular}
    Boundary cell prescription at coordinate singularities.
    The $\pm$ signs are to be chosen such that the resulting cell exists and
    is located within the domain.
  }
\end{table}
\item Runs involving a magnetic field pose the additional difficulty that the
inward-pointing $B$ component
($B_R$ for $R=0$, $B_{\vartheta}$ for $\vartheta \in \{0,\pi\}$, and $B_r$
for $r=0$) is localized exactly at the singularity, at which the field
integration diverges.
Therefore, this component has to be replaced by a finite value computed
from the magnetic field at the surrounding cells, while the electric field
receives a corresponding treatment.
\end{enumerate}
This will keep the axis fields finite, but has not yet been extended to the
spherical origin case. Therefore, MHD simulations involving the spherical
origin are not currently possible at all, while for HD runs, the user has to
implement the proper boundary conditions according to
Table.~\ref{tab:singular} himself.
For boundaries at which a singularity is present, the specified boundary
condition (unless equal to {\tt 4}, see Section~\ref{sect:catfile}) will be
overridden by the code, and is therefore irrelevant.



\subsection{Extended equations}
\label{sec:extend}

\subsubsection{Add new equations}

The set of variable fields \mbox{$\{\rho,{\bf u}, {\bf B}, e\}$} can be
extended by a arbitrary number of additional fields if so desired.
To do so, you need to
\begin{enumerate}
\item edit {\tt constants.H} by setting \mbox{\tt OMS\_USER = TRUE}
  and {\tt N\_OMINT\_USER} equal to the number of additional
  variable fields,
\item supply formulas for the physical fluxes (the divergence part of
  the equations, without the divergence operator itself), and
\item implement initial conditions, boundary conditions, and source
  terms if applicable (see above).
\end{enumerate}
For example, to add a passively advected scalar field $\psi$ (i.e.\ a
field which obeys
\[ \partial \psi + \nabla \cdot (\psi {\bf u})=0 \]
but does not exert pressure or any other back-reaction upon the usual
fluid), set \mbox{\tt N\_OMINT\_USER = 1} and implement
\begin{verbatim}
void mySim::get_PhysFluxUser(Data &gdata,
                             cronos::vector<REAL> &iPos,
                             phys_fields_1D &pf,
                             phys_fields_1D &pfUser,
                             int dir, REAL shift) {
	
  pfUser.flux[0].clear();
  for (int i = -1; i <= gdata.mx[dir]+1; ++i)
    pfUser.flux[0](i) = pfUser.uPri[0](i)*pf.uPri[1+dir](i);
}
\end{verbatim}
within the mod file.
This provides the physical fluxes (the term inside the divergence
operator) for direction {\tt dir} (0,1,2 for $x,y,z$) and user
variable number {\tt 0} at grid cell {\tt i} as a function of that
variable ({\tt pfUser.uPri}) and the standard variable ({\tt pf.uPri})
number $q=1+{\tt dir}$. In other words, the above is equivalent to
\begin{equation}
  \mbox{flux}(\psi)_i = \left\{ \begin{array}{ccc}
    \psi \ (u_x)_i &:& {\tt dir} = 0 \\
    \psi \ (u_y)_i &:& {\tt dir} = 1 \\
    \psi \ (u_z)_i &:& {\tt dir} = 2 \\
  \end{array} \right.
\end{equation}

\subsubsection{Boundary conditions for additional variables}

In this example, boundary conditions for $\psi$ could be chosen in
analogy to those for $\rho$. One small complication may arise from the
fact that the argument {\tt q} is used to refer to both {\tt om[q]}
and {\tt om\_user[q]}, while different implementations will be
generally be desired for both cases. To discriminate the two cases,
\begin{verbatim}
if (q == 0) { ... <code for om[0] / om_user[0]> }
\end{verbatim}
could be replaced by something like
\begin{verbatim}
if (omb.getName() == "rho")
  { ... <code for om[0]>  }
else if (omb.getName() == "om_user0")
  { ... <code for om_user[0]> }
\end{verbatim}
Note that the default name \ {\tt om\_user$\left<q\right>$} \ for the
additional variable $q$ can be changed to a more descriptive string
using \\ 
{\tt gdata.om[$q$].rename("{\rm new name}") } \\
during the initialization. Applying this method to also customize the
names for the standard fields is possible but strongly advised
against, except when switching from {\bf B} to {\bf A} initialization
(see Section~\ref{sec:init_fields}).


\subsubsection{Source terms for additional variables}

A source term is not needed in this example, but
could for instance be useful if the tracer particles are to be
inserted continuously during the simulation, rather than being present
right from the start: If $Q_{\rm s}(t)$ is the output strength of a
ball-shaped source of radius $r_{\rm s}$ (per cell volume) that moves
through the computational volume along an $[x_{\rm s}(t),0,z_{\rm s}(t)]$
trajectory, one could use
\begin{verbatim}
REAL t = gdata.time;
for (int k = 0; k <= gdata.mx[2]; ++k) {
  REAL z = get_z(k);
  for (int j = 0; j <= gdata.mx[1]; ++j) {
    REAL y = get_y(j);
    for (int i = 0; i <= gdata.mx[0]; ++i) {
      REAL x = get_x(i);
      if (sqr(x-x_s(t))+sqr(y)+sqr(z-z_s(t)) <= sqr(r_s))
        nom_user[0](i,j,k) -= Q_s(t);
    }
  }
}
\end{verbatim}
to implement that into  \verb+mySim::src_User+. (Note that for
non-Cartesian coordinates, $Q(t)$ would need to be normalized to the
cell volume, which can be computed using the relevant scale factors
$[h_1,h_2,h_3]$, or, more, conveniently, using the {\tt get\_CellVolume} member
function of {\tt gdata}, see Table~\ref{tab:struct_gdata}.\\
{\tt REAL sqr (REAL arg)} is a member function from the {\tt util} class,
which returns {\tt arg*arg}, i.e.\ the square of the argument.


\subsubsection{Extend existing equations}

Additional terms of divergence form for the standard equations
should {\it not} be implemented as source terms but as flux terms to
take advantage of the conservative properties of the scheme. This is
achieved in close analogy to the case for new variable fields, except that
\begin{enumerate}
\item the procedure is now called
  {\tt void mySim::get\_Physflux($\ldots$)} (but uses the same list of
  arguments),
\item {\tt pf.flux[$q$](i)} gets modified rather than
  {\tt pfUser.flux[$q$](i)},
\item the {\tt clear()} command is omitted, and the new terms are added
  (via {\tt +=}) rather than assigned ({\tt =}) in order to preserve
  the terms already introduced by the standard fluxes.
\end{enumerate}




\subsection{The cat file}
\label{sect:catfile}

At init, the parameters to be used in a given simulation are read in
from the cat file {\it pname}{\tt .cat} residing in directory
{\it datadir}. This is a text file with lines of pattern \\
\centerline{\tt keyword = {\it value}.}
Table \ref{tab:keywords} lists the keywords which have to be present.

\begin{table}
\begin{tabular}{|ll|} \hline
  {\tt nproc\{x,y,z\}} & number of processors in x,y,z direction \\
  {\tt reorder} & allow code to change space partition ($\ne$ {\tt 0}) \\
  & or enforce usage of {\tt nproc\{x,y,z\}} ({\tt 0}) \\
  {\tt cfl\_threshold} & max. value for global CFL number \\
  {\tt cfl\_min} & min. value for global CFL number \\
  {\tt runtime} & seconds of real time after which run terminates \\
  {\tt t\_end } & final simulation time \\
  {\tt dt     } & initial timestep \\
  {\tt dt\_\{bin,float,ascii,} & time interval for various outputs \\
  \quad \ {\tt info,mov\} } & \\
  {\tt num\_\{bin,float,ascii,} & write output every $n$ (integer) timesteps \\
  \quad \ {\tt info\} } & \\
%        {\tt dt\_debug} & (???) \\  
  {\tt N\{x,y,z\}} & spatial resolution $N_{x,y,z}$ \\
  {\tt m\{x,y,z\}} & spatial resolution $N_{x,y,z}-1$ (see comments in
  Section~\ref{sect:catfile}) \\
  {\tt \{x,y,z\}b} & lower bounds of physical volume ($\{x,y,z\}_0$) \\
  {\tt \{x,y,z\}e} & upper bounds of physical volume ($\{x,y,z\}_N$) \\
  {\tt ScaleGrid} & {\tt 0} disables {\tt scale\_\{x,y,z\}}, $\ne$ {\tt 0}
  will enable it. \\
  {\tt scale\_\{x,y,z\}} & physical bounds are in units of
  $\pi$ ({\tt pi}, {\tt Pi}), \\
  & $\exp(1)$ ({\tt e}), or $1$ ({\tt 1}) \\ 
  {\tt grid\_\{x,y,z\}} & type of grid mapping to use
  (see Section~\ref{sect:nonlin-grid}) \\
  {\tt type } & type number of problem (cf. {\tt modules.C}) \\
  {\tt restart} & continue existing simulation ({\tt 1}) or start
  anew ({\tt 0}) \\
  {\tt restart\_step} & timestep from which to restart (if applicable) \\
  {\tt Limiter} & Use minmod ({\tt 1}) or van Leer limiter ({\tt 2}) \\
  {\tt RiemannSolver} & Riemann solver to use. Possible choices are\\
  & {\tt hll}, {\tt hllc}, or {\tt hlld}. (See Section~\ref{sect:riemann}.) \\
%  {\tt Theta} & $\Theta$ value for limiter (usually equal to unity) \\
  {\tt bc\_\{x,y,z\}\_bot} & boundary conditions at
  $\{x,y,z\}=\{x_0,y_0,z_0\}$ (see above)\\
  {\tt bc\_\{x,y,z\}\_top} & boundary conditions at
  $\{x,y,z\}=\{x_N,y_N,z_N\}$ \\
  {\tt mag} & magnetic field present ({\tt 1}) or not ({\tt 0}) \\
  {\tt Adiabatic\_exponent} & $\gamma$ value to be used \\
  {\tt Initial\_density} & {\tt REAL rho0} member of Problem class
  (see Section~\ref{sect:NRG})\\
  {\tt Isothermal\_Soundspeed} & square root of {\tt REAL cs2}
  member variable \\
%Base_density = 1.0
%Base_temperature = 2.5
%Plasma_beta = 1.e99 0.01
%Resistivity = 0
%--------------- Solar wind params ---------
%Central_Mass = 1.0
%Dipole_Strength = 4.0
  %------------------- PhysTest --------------
  {\tt rhomin} & lowest admissible density during run \\
  {\tt pmin}   & lowest admissible pressure during run \\
  {\tt vmax}   & highest admissible velocity during run \\
  %rand = 0
%----------------- ( obsolete ) ------------
  \hline
\end{tabular}
\caption{\label{tab:keywords} Mandatory keywords in the cat file.}
\end{table}

\noindent
Some comments:
\begin{itemize}
\item For parallel runs, the product of all {\tt nproc}s has to be
  equal to the total number of processors used, i.e.\ equal to
  the product of the {\tt nproc\{x,y,z\}} cat entries.
  Also, each {\tt N\{x,y,z\}} (or 1+{\tt m\{x,y,z\}}) has to be an
  integer multiple of {\tt nproc\{x,y,z\}}.
\item To prevent a run from finishing prematurely, {\tt runtime}
  can be given extremely high values.
\item {\tt dt} will only be used for the first timestep, while the
  stepsize will then be CFL-controlled (except to match the intervals
  for data output).
\item Possible values for {\tt bc\_\{x,y,z\}\_\{top,bot\}} are:
  \begin{center}
    \begin{tabular}{rcl}
      0  &:&  Periodic \\
      1  &:&  Periodic (with data at mx to be overwritten) \\
      2  &:&  Extrapolation \\
      3  &:&  Outflow \\
      4  &:&  User-defined local bcs (from {\tt bc\_User} routine) \\
      5  &:&  Reflecting boundaries \\
    \end{tabular}
  \end{center}
\item The recommended way to specify the grid size and extension is by
  providing the number of grid cells in each direction via {\tt N\{x,y,z\}}.
  If all three of them are set, {\tt \{x,y,z\}b} and {\tt \{x,y,z\}e}
  designate the physical coordinates of the first and last cell's outer face
  in the respective direction, and the contents of {\tt m\{x,y,z\}} is ignored.
  (For instance, to cover the complete {\tt y} interval $[0,2\pi]$ with ten
  cells, use {\tt yb=0}, {\tt ye=2}, {\tt scale\_y=pi}, and {\tt Ny=10}.)
  Alternatively, the outer cells can be clipped, as described in
  Section~\ref{grid+coords}, by omitting (at least one of) the
  {\tt N\{x,y,z\}} and giving the highest cell-centered index (i.e.\
  $N_{x,y,z}-1$) in {\tt m\{x,y,z\}}. In this case, {\tt \{x,y,z\}b} and
  {\tt \{x,y,z\}e} are the centers of the outermost cells (prior to clipping).
  To achieve the same coverage of $[0,2\pi]$, one would use {\tt yb=0.1},
  {\tt ye=1.9}, {\tt scale\_y=pi}, and {\tt my=9}. If both {\tt N\{x,y,z\}}
  and {\tt m\{x,y,z\}} are given, the former takes precedence.
\end{itemize}


\subsection{Non-linearly scaled grids}
\label{sect:nonlin-grid}


%	// Grid parametrisations:
%	// (0) - linear
%

\textsc{Cronos} also allows for a non-linear grid to be used in the
simulations. So far this grid still has to be an orthogonal one.
This allows the coordinates values along coordinate axes to be stored
in a 1D array for each direction after the user has specified the
transformation to be applied for a given coordinate direction: While for
linear grids the relation between cell index and physical location for a
given coordinate direction $u \in \{x,y,z\}$ is given by Eqs.
\mbox{(\ref{xi_lin} -- \ref{zi_lin})} with
\mbox{$\Delta u \equiv (u_{\rm e}-u_{\rm b})/N_u$}, the user may in
addition specify a strictly monotonous function
\mbox{$f_u:= [0,1] \mapsto [0,1]$} that defines a modified mapping
\begin{equation}
  u_i = u_{\rm b} + (u_{\rm e}-u_{\rm b}) \ f_u \left(\frac{i+1/2}{N_u}\right)
\end{equation}
of cell index $i$ to location $u_i$ while satisfying $u_{-1/2}=u_{\rm b}$ and
 $u_{N_u+1/2}=u_{\rm e}$, such that the grid extent is left unchanged.
 Here, $u_{\rm e}$ and $u_{\rm b}$ denote
the domain boundaries as given in the cat file (see Section~\ref{sect:catfile}).
Note that the identity mapping \mbox{$f_{\rm lin}(\zeta) = \zeta$} recovers
the linear case.
It is important that $f$ be strictly monotonous also in the boundary cells
beyond $\zeta \in [0,1]$, since these would otherwise get mapped into
$[0,1]$, i.~e. the actual volume.


\subsubsection{Employing a pre-defined mapping}

The use of non-linearly scaled orthogonal grids is achieved by
\begin{enumerate}
\item setting {\tt NON\_LINEAR\_GRID} to {\tt CRONOS\_ON} in
  {\tt constants.H} and
\item setting \verb+grid_+$c$ {\tt =} $m$ in the cat file, where $m$ is
  an integer denoting the mapping type for coordinate direction
  $c \in {\{\tt x,y,z} \}$, e.~g. \verb+grid_y = 2+.
\end{enumerate}
% 
Currently, available choices for $m$ are
\begin{itemize}
\item[0:] linear mapping $f_{\rm lin}(\zeta)=\zeta$ (which only makes sense
  for debugging purposes),
\item[1:] exponential
  \begin{equation}
    f_{\rm exp}(\zeta) =
    \frac{(u_{\rm e}/u_{\rm b})^{\zeta}-1}{(u_{\rm e}/u_{\rm b})-1}
  \end{equation}
  which can be shown to result in
  \begin{equation}
    u_i = u_{\rm b} \ (u_{\rm e}/u_{\rm b})^{(i/N_u)} \ ,
  \end{equation}
\item[2:] logarithmic $f_{\rm log}(\zeta)
= u_{\rm b} (u_{\rm e}/u_{\rm b})^{\zeta}$
\item[4:] user-defined (see Section~\ref{sec:user-mapping})
\item[5:] percent-wise increase of cell size.
This requires cat entries \verb+cellChange_+$c$

\item[6:] slightly different version of (5)
This requires cat entries \verb+refSize_+$c$
\end{itemize}


\subsubsection{Implementation of a user-defined mapping}
\label{sec:user-mapping}

Internally, each grid mapping is handled by a grid function class which
has to be derived from the abstract base class
\verb+Interface_GridFunction+.
This is done via the method \verb+set_UserGridFunction+ in
{\tt modules.C}, which gets called whenever the cat entry
\verb+grid_+$c$ is set to {\tt 4} for a given direction $u$.
In this method a new mapping is established by instantiating a grid class via
\begin{verbatim}
   myNonlinGrid[dir] = new DerivedUserClass();
\end{verbatim}
where the class \verb+DerivedUserClass+ has to be supplied by the
user, e.g., in one of the usual module files. Here \verb+myNonlinGrid+
is the pointer to the derived class used by the internal routines
generating the grid. Via the class constructor the user should obtain all
variables needed to define the grid. The routine to provide the grid
mapping has to be of the form
\begin{verbatim}
   virtual REAL get_gridFunc(REAL);
\end{verbatim}

As an example, suppose one wants the cell size to increase linearly
by a factor of $m$ over the entire range $[x_{\rm e}, x_{\rm b}]$. 
The cell size at $x$ is proportional to $f^{\prime}(\zeta)$, and the most
general second-order polynomial satisfying $f(0)=0$ and $f(1)=1$ is
$f(\zeta) = b \zeta + (1-b) \zeta^2$. Hence $m$ is fixed from
$m=f^{\prime}(1)/f^{\prime}(0) = (2-b)/b$, resulting in
$f(\zeta)= \zeta [ (m-1) \zeta +2]/(m+1)$.
This is implemented by first adding
\begin{verbatim}
   myNonlinGrid[dir] = new GridFunction_Incease();
\end{verbatim}
under \verb+set_UserGridFunction+ in \verb+modules.C+ and then
implementing the class and its two methods as
\begin{verbatim}
class GridFunction_Increase: public Interface_GridFunction {
public:
   GridFunction_Increase();                // constructor
   virtual REAL get_gridFunc (REAL zeta);  // return f_inc
   REAL _ratio;      // 'm' parameter
};

GridFunction_Increase::GridFunction_Increase() {
   _ratio = value((char*)"cellsize_ratio");
}

REAL GridFunction_Increase::get_gridFunc(REAL zeta) {
   return zeta*((_ratio-1.)*zeta+2.)/(_ratio+1.);
}
\end{verbatim}
in the module file (or possibly in a separate file like \verb+mygrid.H+
and then \verb+#include+-ing it therein. The desired ratio $m$ of cell
sizes is read in from the cat file only once, and the second function then
uses it to build the grid.

Note that parameters \verb+dir,beg,end,len+ are available in
\verb+Interface_Gridfunction+, and may thus be passed to the grid class
for more specialized grid layouts.

\subsection{How to compile and run}

After changes have been made to any of the source files listed in
Section~\ref{sect:userfiles}, a re-compile is needed for the changes to
take effect:
\begin{itemize}
\item When {\tt constants.H} has been altered, a complete rebuild
  is needed. Type \\
  \mbox{\tt make clean \&\& make} to do that. 
\item After modifying {\tt modules.C} or {\em any}
  {\tt mod\_$\star$.H} file, do\\
  \mbox{\tt touch modules.C \&\& make} \ . 
\end{itemize}
Note: {\tt make} will build both the parallel and non-parallel version
of the executable. If you do not need the parallel version, using
{\tt make proj} instead will suffice (and be faster). To build the
parallel version only, use \verb+make proj_MPI+.\\
Changing a cat file does not require a re-build; you can just run
again. The same applies to the case of a modified
{\tt machinefile.local}.
Remember that if your machine has more than one CPU, you can speed up
compilation by using the {\tt -j} option to {\tt make}. For instance,
to employ two CPUs for compilation, use \mbox{\tt make -j2 proj}
instead of \mbox{\tt make proj}.\\
After the compiler has exited with no errors, the compiled executables
{\tt proj} (for single-CPU runs) and/or \verb+make proj_MPI+ are found in a
directory whose name is machine-dependent, e.g. 
{\tt Linux-i386} or {\tt Linux-amd64}.

\subsubsection{Starting a single-CPU run}

The syntax to run a simulation on one CPU at your local machine
(assuming a 64bit architecture) would be \\
{\tt Linux-amd64/proj} {\it datadir} {\it pname} \ .\\
This will read the simulation parameters from the cat file
{\it datadir}{\tt /}{\it pname}{\tt.cat} and write all binary output
into the {\it datadir} directory.
If {\it datadir} and/or {\it pname} are omitted, they will be read
from the environment variables {\tt poub} ({\it datadir}) and
{\tt pname} ({\it  pname}), which have to have been defined previously
in this case using\\
\centerline{{\tt export poub=}{\it datadir} \quad and/or \quad
{\tt export pname=}{\it pname} \ .}

\subsubsection{Starting a parallel run}
\label{sect:run_par}

This requires the call of the executable to be preceded by\\
{\tt mpirun -np $n$ -machinefile machinefile.local}
where $n$ is the number of processors to be used.
Note that the version of mpirun to evoke must match the version of
the MPI compiler. %On TP4's machines, the full path must be given, which is
%{\tt /opt/openmpi-1.6/bin/mpirun} on {\sc skynet} and {\sc fuji}. \\
%, and {\tt /opt/mpichgm-1.2.7p1..16/bin/mpirun} on the Opteron cluster.
%Do not use {\tt /usr/bin/mpirun} (which only exists on host {\tt o1} anyway).
{\tt machinefile.local} is a text file containing a list of the available
machines, where each line consists of a hostname, optionally followed
by a {\tt :} and the number of cores to be used on that machine. If just one
hostname is involved (such as for {\sc skynet}/{\sc fuji}), this keyword
is not needed.
Usually the full path to the data directory must be given. Make
sure you can login to each host (via {\tt ssh} {\it hostname}) without
having to enter your password.
For time-consuming computations, it has proven advantageous to be able to
close the window in mid-run (and to keep the simulation running even if
the terminal gets closed accidentally). To do this (and to alternatively pipe
the text output into a file {\it protocol.txt}), use \\
{\tt nohup} [above command line] \verb+>+ {\it protocol}{\tt .txt} \verb+&+ \\
after which you can use {\tt tail -f} {\it protocol}{\tt .txt} to continuously
view the output that is currently being generated.

\subsection{Makefile}
\label{sect:makefile}
The application's {\tt Makefile} allows the user to specify additional
compilation flags and/or to include external directories or source code
by setting the following variables at the beginning of the {\tt Makefile}.

\begin{description}
\item[{\tt APPLICATION\_OFLAGS}]{\ }\\
  specifies additional compilation flags. Default: {\tt -DNDEBUG} (disables assertions)
  
\item[{\tt APPLICATION\_INCLUDE}]{\ }\\
  Additional directories that should be included in the compilation (no {\tt -I} prefix required). Default: {\it empty}
  
\item[{\tt APPLICATION\_CXX}]{\ }\\
  Additional source files that should be compiled. Default: {\it empty}

\end{description}
